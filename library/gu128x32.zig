const std = @import("std");
const math = std.math;

const pico = @import("../pico.zig");
const csdk = pico.csdk;
const hardware = pico.hardware;
const spi = hardware.spi;
const gpio = hardware.gpio;

pub const GU128x32 = struct {
    const Self = @This();

    spi: spi.SPI,
    cmd_data_pin: gpio.Pin,
    frame_pulse_pin: gpio.Pin,
    display_buffer: DisplayBuffer,

    pub fn create(
        sck_pin: gpio.Pin,
        tx_pin: gpio.Pin,
        rx_pin: gpio.Pin,
        cs_pin: gpio.Pin,
        cmd_data_pin: gpio.Pin,
        frame_pulse_pin: gpio.Pin,
        spi_hw: spi.SPI.SpiHw,
    ) Self {
        const min_cycle_time_ns = 80 * 2; //80 * 2;
        const baudrate_hz = math.pow(u32, 10, 9) / min_cycle_time_ns;
        return Self{
            .spi = spi.SPI.create(
                sck_pin,
                tx_pin,
                rx_pin,
                cs_pin,
                spi_hw,
                baudrate_hz,
                .idle_high,
                .second_edge,
            ),
            .cmd_data_pin = cmd_data_pin,
            .frame_pulse_pin = frame_pulse_pin,
            .display_buffer = DisplayBuffer.create(),
        };
    }

    pub fn init(self: *Self) void {
        self.display_buffer.clear();

        // == Initialize SPI ==
        self.spi.init();
        self.cmd_data_pin.init(.{
            .direction = .out,
        });

        // == Display initialization sequence ==
        // Clear the display
        self.writeCommand(DisplayClear{
            .byte1 = .{
                .reset_addresses = 1,
                .gram_area0_clear = 1,
                .gram_area1_clear = 1,
            },
        });
        csdk.sleep_ms(2);

        // Set all regions to GRAM
        for (0..8) |idx| {
            self.writeCommand(DisplayAreaSet{
                .byte1 = .{},
                .byte2 = .{
                    .area = @intCast(idx),
                },
                .byte3 = .{},
            });
        }

        // Set up the initial X and Y addresses
        self.writeCommand(pico.library.gu128x32.GU128x32.DataWriteXAddress{
            .byte1 = .{},
            .byte2 = .{
                .gram_x_addr = 0,
            },
        });
        self.writeCommand(pico.library.gu128x32.GU128x32.DataWriteYAddress{
            .byte1 = .{},
            .byte2 = .{
                .gram_y_addr = 0,
            },
        });
    }

    const WriteType = enum(u1) {
        command = 1,
        data = 0,
    };

    pub fn write(self: *Self, write_type: WriteType, data: u8) void {
        self.cmd_data_pin.put(write_type == .command);
        // pico.stdio.print("transmit: {X:0>2}\n", .{data});
        self.spi.write(1, [_]u8{data}, true);
    }

    pub const DisplayOnOff = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u2 = 0,
            layer_0: enum(u1) {
                inactive = 0,
                active = 1,
            },
            layer_1: enum(u1) {
                inactive = 0,
                active = 1,
            },
            reserved_1: u4 = 0b0010,
        },

        byte2: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u2 = 0,
            xor_op: u1,
            and_op: u1,
            gram_invert: enum(u1) {
                normal = 0,
                invert = 1,
            },
            reserved_1: u1 = 0,
            gram_enable: enum(u1) {
                off = 0,
                on = 1,
            },
            reserved_2: u1 = 0,
        },
    };

    pub const BrightnessSet = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            brightness: u4,
            reserved_0: u4 = 0b0100,
        },
    };

    pub const DisplayClear = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reset_addresses: u1,
            reserved_0: u1 = 1,
            gram_area0_clear: u1,
            gram_area1_clear: u1,
            reserved_1: u4 = 0b0101,
        },
    };

    pub const DisplayAreaSet = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u8 = 0b01100010,
        },

        byte2: packed struct {
            const write_type: WriteType = .command;

            area: u3,
            reserved_0: u5 = 0b00000,
        },

        byte3: packed struct {
            const write_type: WriteType = .data;

            reserved_0: u8 = 0b11111111,
        },
    };

    pub const DataWriteXAddress = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u8 = 0b01100100,
        },

        byte2: packed struct {
            const write_type: WriteType = .command;

            gram_x_addr: u7,
            reserved_0: u1 = 0,
        },
    };

    pub const DataWriteYAddress = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u8 = 0b01100000,
        },

        byte2: packed struct {
            const write_type: WriteType = .command;

            gram_y_addr: u4,
            reserved_0: u4 = 0b0000,
        },
    };

    pub const DataStartXAddress = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u8 = 0b01110000,
        },

        byte2: packed struct {
            const write_type: WriteType = .command;

            x_addr: u8,
        },
    };

    pub const DataStartYAddress = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u1 = 0,
            shift: enum(u2) {
                shift_none = 0b00,
                shift_8_dots = 0b01,
                shift_1_dots = 0b10,
                shift_2_dots = 0b11,
            },
            ud: enum(u1) {
                scrolled_up = 1,
                scrolled_down = 0,
            },
            reserved_1: u4 = 0b1011,
        },
    };

    pub const AddressModeSet = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u1 = 0,
            increment_y: enum(u1) {
                fixed = 0b0,
                increment = 0b1,
            },
            increment_x: enum(u1) {
                fixed = 0b0,
                increment = 0b1,
            },
            reserved_1: u5 = 0b10000,
        },
    };

    pub const AddressRead = struct {
        byte1: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u8 = 0b11010100,
        } = .{},
        byte2: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u8 = 0b00000000,
        } = .{},
        byte3: packed struct {
            const write_type: WriteType = .command;

            reserved_0: u8 = 0b00000000,
        } = .{},
    };

    pub const DataWrite = struct {
        byte1: packed struct {
            const write_type: WriteType = .data;

            data: u8,
        },
    };

    pub fn writeCommand(self: *Self, cmd: anytype) void {
        const info = @typeInfo(@TypeOf(cmd));

        //Loop through each byte field in the command
        const fields = info.Struct.fields;
        inline for (fields) |field| {
            //Get the command byte
            const cmd_byte = @field(cmd, field.name);
            //Extract the data from the command byte
            const write_type = @TypeOf(cmd_byte).write_type;
            const data: u8 = @bitCast(cmd_byte);
            //Write over SPI
            self.write(write_type, data);
        }
    }

    pub fn render(self: *Self) void {
        // Set the write address back to 0
        self.writeCommand(pico.library.gu128x32.GU128x32.DataWriteXAddress{
            .byte1 = .{},
            .byte2 = .{
                .gram_x_addr = 0,
            },
        });

        // Go through the display buffer
        for (self.display_buffer.display_buffer, 0..) |line, line_idx| {

            // Advance to the next line
            self.writeCommand(pico.library.gu128x32.GU128x32.DataWriteYAddress{
                .byte1 = .{},
                .byte2 = .{
                    .gram_y_addr = @intCast(line_idx),
                },
            });

            for (line) |segment| {
                self.writeCommand(DataWrite{ .byte1 = .{
                    .data = segment,
                } });
            }
        }
    }
};

pub const DisplayBuffer = struct {
    const Self = @This();

    pub const num_lines = 4;
    pub const num_columns = 128;

    display_buffer: [num_lines][num_columns]u8 = undefined,

    pub fn create() Self {
        var self = Self{};

        self.clear();

        return self;
    }

    pub fn clear(self: *Self) void {
        // Clear the display buffer
        for (&self.display_buffer) |*line| {
            // for (line) |*segment| {
            //     segment.* = 0;
            // }
            @memset(line, 0);
        }
    }

    /// Sets a pixel in the display buffer
    ///
    /// x: [0, 127]
    ///
    /// y: [0, 32]
    pub inline fn setPixel(self: *Self, x: u7, y: u5, pixel: bool) void {
        const line_idx: u2 = @intCast(y >> 3);
        const bit_pos: u3 = @truncate(y);

        const mask: u8 = ~(@as(u8, 1) << bit_pos);

        self.display_buffer[line_idx][x] = (self.display_buffer[line_idx][x] & mask) | (@as(u8, @intFromBool(pixel)) << bit_pos);
    }

    // The Bresenham Line Drawing Algorithm
    pub fn drawLine(self: *Self, x1: u7, y1: u5, x2: u7, y2: u5, pixel: bool) void {
        const x_min: u16 = @min(x1, x2);
        const x_max: u16 = @max(x1, x2);

        const y_min: u16 = @min(y1, y2);
        const y_max: u16 = @max(y1, y2);

        const dx: i16 = @as(i16, @intCast(x_max)) - @as(i16, @intCast(x_min));
        const dy: i16 = @as(i16, @intCast(y_max)) - @as(i16, @intCast(y_min));

        if (dy <= dx) {
            // Horizontal line

            var px = 2 * dy - dx;
            var y: i16 = y1;
            for (x_min..x_max + 1) |x| {
                setPixel(self, @intCast(x), @intCast(y), pixel);

                if (px < 0) {
                    px = px + 2 * dy;
                } else {
                    y += if (dy >= 0) 1 else -1;
                    px = px + 2 * (dy - dx);
                }
            }
        } else {
            //Vertical line

            var py = 2 * dx - dy;
            var x: i16 = x1;
            for (y_min..y_max + 1) |y| {
                setPixel(self, @intCast(x), @intCast(y), pixel);

                if (py <= 0) {
                    py = py + 2 * dx;
                } else {
                    x += if (dx >= 0) 1 else -1;
                    py = py + 2 * (dx - dy);
                }
            }
        }
    }

    pub fn drawRectangle(self: *Self, x1: u7, y1: u5, x2: u7, y2: u5, pixel: bool) void {
        // Draw horizontal lines
        for (x1..@as(u16, x2 + 1)) |x| {
            self.setPixel(@intCast(x), y1, pixel);
            self.setPixel(@intCast(x), y2, pixel);
        }
        // Draw vertical lines
        // Skip first and last row since horizontal lines already took care of that
        for (y1 + 1..y2) |y| {
            self.setPixel(x1, @intCast(y), pixel);
            self.setPixel(x2, @intCast(y), pixel);
        }
    }

    pub fn fillRectangle(self: *Self, x1: u7, y1: u5, x2: u7, y2: u5, pixel: bool) void {
        const start_line = y1 / 8;
        const end_line = y2 / 8;
        const lower_bits_off: u3 = @intCast(y1 % 8);
        const upper_bits_off: u3 = 7 - @as(u3, @intCast(y2 % 8));

        const upper_mask: u8 = (@as(u8, 0xFF) >> lower_bits_off) << lower_bits_off;
        const lower_mask: u8 = (@as(u8, 0xFF) << upper_bits_off) >> upper_bits_off;
        const combined_mask: u8 = upper_mask & lower_mask;

        const pixel_column: u8 = if (pixel) 0xFF else 0;

        for (start_line..end_line + 1) |line| {
            for (x1..@as(u16, x2 + 1)) |x| {
                if (line == start_line and line == end_line) {
                    // The rectangle is smaller than a single line
                    // ..1111..
                    self.display_buffer[line][x] = (self.display_buffer[line][x] & ~combined_mask) | (pixel_column & combined_mask);
                } else if (line == start_line) {
                    // The upper part of this line is cut off (therefore we turn on the lower pixes, which are the higher bits)
                    // 1111..
                    self.display_buffer[line][x] = (self.display_buffer[line][x] & ~upper_mask) | (pixel_column & upper_mask);
                } else if (line == end_line) {
                    // The lower part of this line is cut off (therefore we turn on the upper pixes, which are the lower bits)
                    // ..1111
                    self.display_buffer[line][x] = (self.display_buffer[line][x] & ~lower_mask) | (pixel_column & lower_mask);
                } else {
                    // The whole line is on
                    // 11111111
                    self.display_buffer[line][x] = pixel_column;
                }
            }
        }
    }

    const PrintConfig = struct {
        self: *Self,
        line: u2,
        x_offset: u7,
    };
    const char_width = 5;

    fn strWrite(self: *Self, str: []const u8, line: u2, x_offset: u7) u7 {
        var current_char_column = x_offset;

        for (str) |char| {
            // pico.stdio.print("{c} [{d}]:\n", .{ char, char });

            for (0..char_width) |char_data_column| {
                // Check for overflow off the right side of the screeen
                if (@as(u8, current_char_column) + char_width >= num_columns) {
                    return num_columns - 1;
                }

                // Get the character data from the data block
                const font_data_idx: u16 = @as(u16, char) * char_width + @as(u16, @intCast(char_data_column));
                const character_data = font_data[font_data_idx];

                // Draw to the screen
                const display_column = current_char_column + char_data_column;
                // pico.stdio.print("column: {}  font_data_idx: {}  data: {X:0>2}\n", .{ display_column, font_data_idx, character_data });

                self.display_buffer[line][display_column] = character_data;
            }

            // Move to the position of the next char
            // Saturating add
            current_char_column +|= char_width + 1;
        }

        return current_char_column;
    }

    fn strWriteFn(context: *const anyopaque, bytes: []const u8) anyerror!usize {
        const print_config: *PrintConfig = @constCast(@alignCast(@ptrCast(context)));
        const self = print_config.self;

        const next_x_offset = self.strWrite(bytes, print_config.line, print_config.x_offset);

        // Check for overflow off the right side of the screen
        if (next_x_offset < num_columns) {
            print_config.x_offset = @intCast(next_x_offset);
        } else {
            // Set to the max so that no more characters can be printed
            print_config.x_offset = num_columns - 1;
        }

        return bytes.len;
    }

    pub fn print(self: *Self, comptime fmt: []const u8, args: anytype, line: u2, x_offset: u7) void {
        var print_config = PrintConfig{
            .self = self,
            .line = line,
            .x_offset = x_offset,
        };

        std.fmt.format(
            std.io.AnyWriter{
                .context = &print_config, // Unused
                .writeFn = strWriteFn,
            },
            fmt,
            args,
        ) catch {};
    }
};

//https://github.com/adafruit/Adafruit-GFX-Library.git
//glcdfont.c
const font_data = [_]u8{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 0x3E, 0x6B,
    0x4F, 0x6B, 0x3E, 0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x18, 0x3C, 0x7E, 0x3C,
    0x18, 0x1C, 0x57, 0x7D, 0x57, 0x1C, 0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 0x00,
    0x18, 0x3C, 0x18, 0x00, 0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 0x00, 0x18, 0x24,
    0x18, 0x00, 0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 0x30, 0x48, 0x3A, 0x06, 0x0E,
    0x26, 0x29, 0x79, 0x29, 0x26, 0x40, 0x7F, 0x05, 0x05, 0x07, 0x40, 0x7F,
    0x05, 0x25, 0x3F, 0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 0x7F, 0x3E, 0x1C, 0x1C,
    0x08, 0x08, 0x1C, 0x1C, 0x3E, 0x7F, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x5F,
    0x5F, 0x00, 0x5F, 0x5F, 0x06, 0x09, 0x7F, 0x01, 0x7F, 0x00, 0x66, 0x89,
    0x95, 0x6A, 0x60, 0x60, 0x60, 0x60, 0x60, 0x94, 0xA2, 0xFF, 0xA2, 0x94,
    0x08, 0x04, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x20, 0x10, 0x08, 0x08,
    0x2A, 0x1C, 0x08, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x1E, 0x10, 0x10, 0x10,
    0x10, 0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 0x30, 0x38, 0x3E, 0x38, 0x30, 0x06,
    0x0E, 0x3E, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F,
    0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14,
    0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23, 0x13, 0x08, 0x64, 0x62, 0x36, 0x49,
    0x56, 0x20, 0x50, 0x00, 0x08, 0x07, 0x03, 0x00, 0x00, 0x1C, 0x22, 0x41,
    0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x08,
    0x08, 0x3E, 0x08, 0x08, 0x00, 0x80, 0x70, 0x30, 0x00, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02,
    0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x72, 0x49,
    0x49, 0x49, 0x46, 0x21, 0x41, 0x49, 0x4D, 0x33, 0x18, 0x14, 0x12, 0x7F,
    0x10, 0x27, 0x45, 0x45, 0x45, 0x39, 0x3C, 0x4A, 0x49, 0x49, 0x31, 0x41,
    0x21, 0x11, 0x09, 0x07, 0x36, 0x49, 0x49, 0x49, 0x36, 0x46, 0x49, 0x49,
    0x29, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00,
    0x00, 0x08, 0x14, 0x22, 0x41, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x41,
    0x22, 0x14, 0x08, 0x02, 0x01, 0x59, 0x09, 0x06, 0x3E, 0x41, 0x5D, 0x59,
    0x4E, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x3E,
    0x41, 0x41, 0x41, 0x22, 0x7F, 0x41, 0x41, 0x41, 0x3E, 0x7F, 0x49, 0x49,
    0x49, 0x41, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x3E, 0x41, 0x41, 0x51, 0x73,
    0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x20, 0x40,
    0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x7F, 0x40, 0x40, 0x40,
    0x40, 0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x3E,
    0x41, 0x41, 0x41, 0x3E, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x3E, 0x41, 0x51,
    0x21, 0x5E, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x26, 0x49, 0x49, 0x49, 0x32,
    0x03, 0x01, 0x7F, 0x01, 0x03, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x1F, 0x20,
    0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x63, 0x14, 0x08, 0x14,
    0x63, 0x03, 0x04, 0x78, 0x04, 0x03, 0x61, 0x59, 0x49, 0x4D, 0x43, 0x00,
    0x7F, 0x41, 0x41, 0x41, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x41, 0x41,
    0x41, 0x7F, 0x04, 0x02, 0x01, 0x02, 0x04, 0x40, 0x40, 0x40, 0x40, 0x40,
    0x00, 0x03, 0x07, 0x08, 0x00, 0x20, 0x54, 0x54, 0x78, 0x40, 0x7F, 0x28,
    0x44, 0x44, 0x38, 0x38, 0x44, 0x44, 0x44, 0x28, 0x38, 0x44, 0x44, 0x28,
    0x7F, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x08, 0x7E, 0x09, 0x02, 0x18,
    0xA4, 0xA4, 0x9C, 0x78, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x44, 0x7D,
    0x40, 0x00, 0x20, 0x40, 0x40, 0x3D, 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,
    0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C, 0x04, 0x78, 0x04, 0x78, 0x7C, 0x08,
    0x04, 0x04, 0x78, 0x38, 0x44, 0x44, 0x44, 0x38, 0xFC, 0x18, 0x24, 0x24,
    0x18, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x48,
    0x54, 0x54, 0x54, 0x24, 0x04, 0x04, 0x3F, 0x44, 0x24, 0x3C, 0x40, 0x40,
    0x20, 0x7C, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x3C, 0x40, 0x30, 0x40, 0x3C,
    0x44, 0x28, 0x10, 0x28, 0x44, 0x4C, 0x90, 0x90, 0x90, 0x7C, 0x44, 0x64,
    0x54, 0x4C, 0x44, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x77, 0x00,
    0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x02, 0x01, 0x02, 0x04, 0x02, 0x3C,
    0x26, 0x23, 0x26, 0x3C, 0x1E, 0xA1, 0xA1, 0x61, 0x12, 0x3A, 0x40, 0x40,
    0x20, 0x7A, 0x38, 0x54, 0x54, 0x55, 0x59, 0x21, 0x55, 0x55, 0x79, 0x41,
    0x22, 0x54, 0x54, 0x78, 0x42,
    // a-umlaut
    0x21, 0x55, 0x54, 0x78, 0x40, 0x20, 0x54,
    0x55, 0x79, 0x40, 0x0C, 0x1E, 0x52, 0x72, 0x12, 0x39, 0x55, 0x55, 0x55,
    0x59, 0x39, 0x54, 0x54, 0x54, 0x59, 0x39, 0x55, 0x54, 0x54, 0x58, 0x00,
    0x00, 0x45, 0x7C, 0x41, 0x00, 0x02, 0x45, 0x7D, 0x42, 0x00, 0x01, 0x45,
    0x7C, 0x40, 0x7D, 0x12, 0x11, 0x12, 0x7D,
    // A-umlaut
    0xF0, 0x28, 0x25, 0x28, 0xF0,
    0x7C, 0x54, 0x55, 0x45, 0x00, 0x20, 0x54, 0x54, 0x7C, 0x54, 0x7C, 0x0A,
    0x09, 0x7F, 0x49, 0x32, 0x49, 0x49, 0x49, 0x32, 0x3A, 0x44, 0x44, 0x44,
    0x3A,
    // o-umlaut
    0x32, 0x4A, 0x48, 0x48, 0x30, 0x3A, 0x41, 0x41, 0x21, 0x7A, 0x3A,
    0x42, 0x40, 0x20, 0x78, 0x00, 0x9D, 0xA0, 0xA0, 0x7D, 0x3D, 0x42, 0x42,
    0x42, 0x3D,
    // O-umlaut
    0x3D, 0x40, 0x40, 0x40, 0x3D, 0x3C, 0x24, 0xFF, 0x24, 0x24,
    0x48, 0x7E, 0x49, 0x43, 0x66, 0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 0xFF, 0x09,
    0x29, 0xF6, 0x20, 0xC0, 0x88, 0x7E, 0x09, 0x03, 0x20, 0x54, 0x54, 0x79,
    0x41, 0x00, 0x00, 0x44, 0x7D, 0x41, 0x30, 0x48, 0x48, 0x4A, 0x32, 0x38,
    0x40, 0x40, 0x22, 0x7A, 0x00, 0x7A, 0x0A, 0x0A, 0x72, 0x7D, 0x0D, 0x19,
    0x31, 0x7D, 0x26, 0x29, 0x29, 0x2F, 0x28, 0x26, 0x29, 0x29, 0x29, 0x26,
    0x30, 0x48, 0x4D, 0x40, 0x20, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x38, 0x2F, 0x10, 0xC8, 0xAC, 0xBA, 0x2F, 0x10, 0x28, 0x34,
    0xFA, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x08, 0x14, 0x2A, 0x14, 0x22, 0x22,
    0x14, 0x2A, 0x14, 0x08, 0x55, 0x00, 0x55, 0x00, 0x55,
    // #176 (25% block) missing in old code
    0xAA, 0x55, 0xAA,
    0x55, 0xAA,
    // 50% block
    0xFF, 0x55, 0xFF, 0x55, 0xFF,
    // 75% block
    0x00, 0x00, 0x00, 0xFF, 0x00,
    0x10, 0x10, 0x10, 0xFF, 0x00, 0x14, 0x14, 0x14, 0xFF, 0x00, 0x10, 0x10,
    0xFF, 0x00, 0xFF, 0x10, 0x10, 0xF0, 0x10, 0xF0, 0x14, 0x14, 0x14, 0xFC,
    0x00, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x14,
    0x14, 0xF4, 0x04, 0xFC, 0x14, 0x14, 0x17, 0x10, 0x1F, 0x10, 0x10, 0x1F,
    0x10, 0x1F, 0x14, 0x14, 0x14, 0x1F, 0x00, 0x10, 0x10, 0x10, 0xF0, 0x00,
    0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x10, 0x10, 0x10,
    0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x00, 0x00, 0x00, 0xFF, 0x14, 0x00,
    0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x1F, 0x10, 0x17, 0x00, 0x00, 0xFC,
    0x04, 0xF4, 0x14, 0x14, 0x17, 0x10, 0x17, 0x14, 0x14, 0xF4, 0x04, 0xF4,
    0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
    0xF7, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x17, 0x14, 0x10, 0x10, 0x1F, 0x10,
    0x1F, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x10, 0x10, 0xF0, 0x10, 0xF0, 0x00,
    0x00, 0x1F, 0x10, 0x1F, 0x00, 0x00, 0x00, 0x1F, 0x14, 0x00, 0x00, 0x00,
    0xFC, 0x14, 0x00, 0x00, 0xF0, 0x10, 0xF0, 0x10, 0x10, 0xFF, 0x10, 0xFF,
    0x14, 0x14, 0x14, 0xFF, 0x14, 0x10, 0x10, 0x10, 0x1F, 0x00, 0x00, 0x00,
    0x00, 0xF0, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x0F,
    0x0F, 0x0F, 0x0F, 0x0F, 0x38, 0x44, 0x44, 0x38, 0x44, 0xFC, 0x4A, 0x4A,
    0x4A, 0x34,
    // sharp-s or beta
    0x7E, 0x02, 0x02, 0x06, 0x06, 0x02, 0x7E, 0x02, 0x7E, 0x02,
    0x63, 0x55, 0x49, 0x41, 0x63, 0x38, 0x44, 0x44, 0x3C, 0x04, 0x40, 0x7E,
    0x20, 0x1E, 0x20, 0x06, 0x02, 0x7E, 0x02, 0x02, 0x99, 0xA5, 0xE7, 0xA5,
    0x99, 0x1C, 0x2A, 0x49, 0x2A, 0x1C, 0x4C, 0x72, 0x01, 0x72, 0x4C, 0x30,
    0x4A, 0x4D, 0x4D, 0x30, 0x30, 0x48, 0x78, 0x48, 0x30, 0xBC, 0x62, 0x5A,
    0x46, 0x3D, 0x3E, 0x49, 0x49, 0x49, 0x00, 0x7E, 0x01, 0x01, 0x01, 0x7E,
    0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x44, 0x44, 0x5F, 0x44, 0x44, 0x40, 0x51,
    0x4A, 0x44, 0x40, 0x40, 0x44, 0x4A, 0x51, 0x40, 0x00, 0x00, 0xFF, 0x01,
    0x03, 0xE0, 0x80, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x6B, 0x6B, 0x08, 0x36,
    0x12, 0x36, 0x24, 0x36, 0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00, 0x00, 0x18,
    0x18, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x40, 0xFF, 0x01, 0x01,
    0x00, 0x1F, 0x01, 0x01, 0x1E, 0x00, 0x19, 0x1D, 0x17, 0x12, 0x00, 0x3C,
    0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00,
    // #255 NBSP
};
